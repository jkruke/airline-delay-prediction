#!/usr/bin/python3
# WARNING: Not yet tested once
# Note: You must install these packages:
# pip install openmeteo-requests
# pip install requests-cache retry-requests numpy pandas pandasql sqlalchemy==1.4.46
# Get CSV with iata locations:
# git clone https://github.com/ip2location/ip2location-iata-icao.git
#
# Or, if you like to live by the mountain cliff and don't use venv:
# sudo pip install openmeteo-requests --break-system-packages
# sudo pip install requests-cache retry-requests numpy pandas pandasql --break-system-packages
# sudo pip install sqlalchemy==1.4.46 --break-system-package
# 
# WARNING: SQLAlchemy 2.* has some problems parsing even simple query, so downgrade it to 1.4.46 is necessary

# TODO: There are a lot of TODO-s. Ctrl+F to see each of them
import pandas as pd
from pandasql import sqldf  # Because working with sql is way simpler

import datetime
from argparse import ArgumentParser

import openmeteo_requests
import requests_cache
from retry_requests import retry

parser = ArgumentParser(prog='get-weather', description='Write weather information to CSV file',
                        epilog='Example usage: $> ./add-weather.py')
parser.add_argument("--airports", help="CSV file listing airports' IATA/ICAO and latlong.",
                    metavar='airports_csv', default="ip2location-iata-icao/iata-icao.csv")
parser.add_argument("FROM", help="Start date (yyyy-mm-dd)")
parser.add_argument("TO", help="End date (yyyy-mm-dd)")
args = parser.parse_args()

print("Querying API request dates")

start_date = args.FROM
end_date = args.TO

print(f"start_date: {start_date}")
print(f"end_date: {end_date}")

# Concat the result of two queries with python because SQLite doesn't have OUTER JOIN
unique_iatas = pd.read_csv("data/affected-airports.csv")
print(f"unique_iatas: {unique_iatas}")

airport_locations = pd.read_csv(args.airports, header=0, usecols=["iata", "latitude", "longitude"])
coordinates = sqldf('''SELECT a.iata, a.latitude, a.longitude 
	FROM unique_iatas AS u INNER JOIN airport_locations AS a 
	ON u.iata == a.iata''')
print(coordinates)
missing_iata = sqldf("SELECT iata FROM unique_iatas where iata not in (SELECT iata from airport_locations)")
print(f"[WARNING] Airports with no location:\n{missing_iata}")

latitudes = coordinates['latitude'].values.tolist()
longitudes = coordinates['longitude'].values.tolist()

## FROM HERE ON IS CODE GENERATED BY OPEN-METEO
## TWEAKED A LITTLE

# Setup the Open-Meteo API client with cache and retry on error
cache_session = requests_cache.CachedSession('data/.cache', expire_after=-1)
retry_session = retry(cache_session, retries=5, backoff_factor=0.2)
openmeteo = openmeteo_requests.Client(session=retry_session)

# Make sure all required weather variables are listed here
# The order of variables in hourly or daily is important to assign them correctly below
url = "https://archive-api.open-meteo.com/v1/archive"
# The list of weather parameters we're interested in
params = {
    "latitude": latitudes,
    "longitude": longitudes,
    "start_date": start_date,
    "end_date": end_date,
    "hourly": [
        "temperature_2m",
        "relative_humidity_2m",
        "precipitation",
        "rain",
        "snowfall",
        "weather_code",
        "cloud_cover",
        "cloud_cover_low",
        "cloud_cover_mid",
        "cloud_cover_high",
        "wind_speed_10m",
        "wind_speed_100m",
        "wind_gusts_10m"
    ],
}

date_format = "%Y-%m-%d"
date_diff = datetime.datetime.strptime(end_date, date_format) - datetime.datetime.strptime(start_date, date_format)
approx_weight = {len(latitudes) * len(params['hourly']) / 14 * date_diff.days * 0.1}
print(
    f"Requesting open-meteo API. Approx query weight: {approx_weight}. That's {approx_weight}/10000 request limit per day.")
# TODO: Figure out how to query a lot, but not too much, at once
# WARNING: You are going to overshoot your limit of 10000 requests/day with just 1 request this big 
responses = openmeteo.weather_api(url, params=params)
print(">Done")

print("Merging all airport weather reports together")
all_weathers_dfs = []
for weather_at_each_airport in responses:
    response = weather_at_each_airport
    # print(f"Coordinates {response.Latitude()}°E {response.Longitude()}°N")
    # print(f"Elevation {response.Elevation()} m asl")
    # print(f"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}")
    # print(f"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s")

    # Process hourly data. The order of variables needs to be the same as requested.
    hourly = response.Hourly()
    hourly_temperature_2m = hourly.Variables(0).ValuesAsNumpy()
    hourly_relative_humidity_2m = hourly.Variables(1).ValuesAsNumpy()
    hourly_precipitation = hourly.Variables(2).ValuesAsNumpy()
    hourly_rain = hourly.Variables(3).ValuesAsNumpy()
    hourly_snowfall = hourly.Variables(4).ValuesAsNumpy()
    hourly_weather_code = hourly.Variables(5).ValuesAsNumpy()
    hourly_cloud_cover = hourly.Variables(6).ValuesAsNumpy()
    hourly_cloud_cover_low = hourly.Variables(7).ValuesAsNumpy()
    hourly_cloud_cover_mid = hourly.Variables(8).ValuesAsNumpy()
    hourly_cloud_cover_high = hourly.Variables(9).ValuesAsNumpy()
    hourly_wind_speed_10m = hourly.Variables(10).ValuesAsNumpy()
    hourly_wind_speed_100m = hourly.Variables(11).ValuesAsNumpy()
    hourly_wind_gusts_10m = hourly.Variables(12).ValuesAsNumpy()

    hourly_data = {"date": pd.date_range(
        start=pd.to_datetime(hourly.Time(), unit="s"),
        end=pd.to_datetime(hourly.TimeEnd(), unit="s"),
        freq=pd.Timedelta(seconds=hourly.Interval()),
        inclusive="left"
    )}
    hourly_data["temperature_2m"] = hourly_temperature_2m
    hourly_data["relative_humidity_2m"] = hourly_relative_humidity_2m
    hourly_data["precipitation"] = hourly_precipitation
    hourly_data["rain"] = hourly_rain
    hourly_data["snowfall"] = hourly_snowfall
    hourly_data["weather_code"] = hourly_weather_code
    hourly_data["cloud_cover"] = hourly_cloud_cover
    hourly_data["cloud_cover_low"] = hourly_cloud_cover_low
    hourly_data["cloud_cover_mid"] = hourly_cloud_cover_mid
    hourly_data["cloud_cover_high"] = hourly_cloud_cover_high
    hourly_data["wind_speed_10m"] = hourly_wind_speed_10m
    hourly_data["wind_speed_100m"] = hourly_wind_speed_100m
    hourly_data["wind_gusts_10m"] = hourly_wind_gusts_10m

    hourly_dataframe = pd.DataFrame(data=hourly_data)
    #### OPEN-METEO CODE SECTION ENDS ####

    lat = response.Latitude()
    long = response.Longitude()
    # The returned coordinates are not exactly accurate, so we have to take them with a grain of salt
    airport_correspond_to_latlong = f"(SELECT * FROM coordinates AS c WHERE ABS(c.latitude - {lat}) < 0.2 AND (c.longitude - {long}) < 0.2)"

    # Bind the weather information to each airport
    airport_weather_df = sqldf(f'''SELECT * from {airport_correspond_to_latlong} CROSS JOIN hourly_dataframe''')
    all_weathers_dfs.append(airport_weather_df)
all_weathers_dfs = pd.concat(all_weathers_dfs)
print(">Done")

outfile = f"data/weather.csv.gz"
print(f"Saving weather reports to {outfile}")
all_weathers_dfs.to_csv(outfile, index=False, compression="gzip")
print(">Done")
